# Local Storage

## Проблеми:

&#160;&#160;&#160;&#160;Веб-сховище (localStorage / sessionStorage) доступне через JavaScript на тому ж домені. Це означає, що будь-який JavaScript, що працює на вашому веб-сайті, матиме доступ до веб-сховища, і через це може бути вразливим до атак міжсайтових сценаріїв (XSS). У двох словах XSS - це тип вразливості, коли зловмисник може ввести JavaScript, який працюватиме на вашій сторінці. Базові атаки XSS намагаються ввести JavaScript за допомогою входів форми, де зловмисник попереджає ("Вас зламали"); у форму, щоб перевірити, чи запускається вона браузером і чи можуть її переглядати інші користувачі.

## Профілактика:
&#160;&#160;&#160;&#160;Щоб запобігти XSS, загальною реакцією є захист та кодування всіх ненадійних даних. Але це далеко не вся історія. У 2015 році сучасні веб-програми використовують JavaScript, розміщений на CDN або за межами інфраструктури. Сучасні веб-програми включають сторонні бібліотеки JavaScript для тестування A / B, аналіз послідовності / ринку та рекламу. Ми використовуємо менеджери пакетів, такі як Bower, щоб імпортувати код інших людей у наші програми.

Що робити, якщо порушено лише один із використовуваних вами сценаріїв? Шкідливий JavaScript можна вбудувати на сторінку, а веб-сховище порушено. Ці типи атак XSS можуть отримати веб-сховище кожного, хто відвідує ваш сайт, без їх відома. Можливо, тому купа організацій радить не зберігати нічого цінного та не довіряти будь-якій інформації у веб-сховищі. Сюди входять ідентифікатори сеансу та маркери.

Як механізм зберігання, Web Storage не застосовує жодних захищених стандартів під час передачі. Той, хто читає та використовує веб-сховище, повинен ретельно перевірити, щоб вони завжди надсилали JWT через HTTPS і ніколи HTTP.

# Cookies

## Проблеми:

&#160;&#160;&#160;&#160;Файли cookie, що використовуються з прапорцем файлів cookie HttpOnly, недоступні через JavaScript і не захищені від XSS. Ви також можете встановити прапорець безпечного файлу cookie, щоб гарантувати, що файл cookie надсилається лише через HTTPS. Це одна з основних причин того, що раніше файли cookie використовувались для зберігання токенів або даних сеансу. Сучасні розробники вагаються щодо використання файлів cookie, оскільки вони традиційно вимагали збереження стану на сервері, порушуючи тим самим найкращі практики RESTful. Файли cookie як механізм зберігання не вимагають збереження стану на сервері, якщо ви зберігаєте JWT у файлі cookie. Це тому, що JWT інкапсулює все, що потрібно серверу для обслуговування запиту.

Однак файли cookie вразливі до іншого типу атаки: підробка міжсайтових запитів (CSRF). Атака CSRF - це тип атаки, який виникає, коли зловмисний веб-сайт, електронна пошта або блог змушує веб-браузер користувача виконувати небажані дії на надійному веб-сайті, на якому користувач в даний час автентифікується. Це опис того, як браузер обробляє файли cookie. Файл cookie можна надсилати лише до тих доменів, у яких це дозволено. За замовчуванням це домен, який спочатку встановив файл cookie. Файл cookie буде надісланий для запиту незалежно від того, перебуваєте ви на galaxies.com або hahagonnahackyou.com.

## Профілактика:

&#160;&#160;&#160;&#160;Сучасні браузери підтримують прапор SameSite, крім HttpOnly та Secure. Призначення цього прапора - запобігти передачі файлів cookie у запитах між сайтами, запобігаючи багатьом випадам CSRF.

Для браузерів, які не підтримують SameSite, CSRF можна запобігти, використовуючи синхронізовані шаблони маркерів. Це звучить складно, але всі сучасні веб-фреймворки мають для цього підтримку.

Наприклад, AngularJS має рішення підтвердити, що файл cookie доступний лише вашому домену. Прямо з документів AngularJS:

Під час виконання запитів XHR служба $ http зчитує маркер із файлу cookie (за замовчуванням XSRF-TOKEN) і встановлює його як заголовок HTTP (X-XSRF-TOKEN). Оскільки файл cookie може читати лише JavaScript, який працює у вашому домені, ваш сервер може бути впевнений, що XHR походить від JavaScript, який працює у вашому домені. Ви можете зробити цей захист CSRF без громадянства, включивши xsrfToken JWT
Використовуючи захист CSRF вашого веб-додатку, файли cookie є надійними для зберігання JWT. CSRF також можна частково запобігти, перевіривши заголовок HTTP Referer та Origin із вашого API. Атаки CSRF матимуть заголовки Referer та Origin, які не пов'язані з вашим додатком.

# Cookies

### Плюси:

- Підтримка застарілої версії (вона існує вічно)
- Постійні дані
- Терміни придатності

### Мінуси:

- Кожен домен зберігає всі свої файли cookie в одному рядку, що може ускладнити аналіз даних
- Дані не шифруються, що стає проблемою, оскільки ... ... хоч і невеликі за розміром, файли cookie надсилаються з кожним запитом HTTP Обмежений розмір (4 КБ)
Введення SQL можна виконати з файлу cookie

# Local Storage

### Плюси:

- Підтримка більшості сучасних браузерів
- Постійні дані, які зберігаються безпосередньо в браузері
- Правила того самого походження застосовуються до даних локального зберігання
- Не надсилається з кожним запитом HTTP ~ 5 МБ пам’яті на домен (це 5120 КБ)

### Мінуси:

- Раніше нічим не підтримується: IE 8, Firefox 3.5, Safari 4, Chrome 4, Opera 10.5, iOS 2.0, Android 2.0
- Якщо серверу потрібна збережена інформація про клієнта, ви спеціально повинні її надіслати.

Використання `localStorage` майже ідентично сесійному. Вони мають досить точні методи, тому перехід від сеансу до `localStorage` - це справді дитяча гра. Однак якщо збережені дані дійсно важливі для вашої програми, ви, ймовірно, використовуватимете файли cookie як резервну копію на випадок, якщо `localStorage` буде недоступний. Якщо ви хочете перевірити підтримку браузера для `localStorage`, все, що вам потрібно зробити, це запустити цей простий скрипт:

```js
1 /* 
2 * function body that test if storage is available
3 * returns true if localStorage is available and false if it's not
4 */
5 function lsTest(){
6     var test = 'test';
7     try {
8         localStorage.setItem(test, test);
9         localStorage.removeItem(test);
10         return true;
11     } catch(e) {
12         return false;
13     }
14 }
15 
16 /* 
17 * execute Test and run our custom script 
18 */
19 if(lsTest()) {
20     // window.sessionStorage.setItem(name, 1); // session and storage methods are very similar
21     window.localStorage.setItem(name, 1);
22     console.log('localStorage where used'); // log
23 } else {
24     document.cookie="name=1; expires=Mon, 28 Mar 2016 12:00:00 UTC";
25     console.log('Cookie where used'); // log
26 }
```

### Cookies:

- Введено до HTML5.
- Має термін придатності.
- Очищається JS або Очищенням даних перегляду браузера або після закінчення терміну дії.
- Буде надіслано на сервер за кожним запитом.
- Ємність - 4 КБ.
- Тільки рядки можуть зберігатись у файлах cookie.
- Існує два типи файлів cookie: постійне та сесійне.

### Local Storage:

- Введено з HTML5.
- Не має терміну придатності.
- Видаляється за допомогою JS або Очищення даних браузера.
- Ви можете вибрати, коли дані повинні надсилатися на сервер.
- Ємність - 5 Мб.
- Дані зберігаються необмежено довго і мають бути рядком.
 -Тільки один тип.

<a href="https://github.com/Quindeci/IPZ">Посилання на репозиторий</a>
